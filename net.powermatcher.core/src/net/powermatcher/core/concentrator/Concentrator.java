package net.powermatcher.core.concentrator;

import java.util.Map;

import org.flexiblepower.context.FlexiblePowerContext;

import aQute.bnd.annotation.component.Activate;
import aQute.bnd.annotation.component.Component;
import aQute.bnd.annotation.component.Deactivate;
import aQute.bnd.annotation.metatype.Configurable;
import aQute.bnd.annotation.metatype.Meta;
import net.powermatcher.api.AgentEndpoint;
import net.powermatcher.api.MatcherEndpoint;
import net.powermatcher.api.Session;
import net.powermatcher.api.data.Bid;
import net.powermatcher.api.data.Price;
import net.powermatcher.api.messages.AllocationUpdate;
import net.powermatcher.api.messages.BidUpdate;
import net.powermatcher.api.messages.PredictionUpdate;
import net.powermatcher.api.messages.PriceUpdate;
import net.powermatcher.api.monitoring.AgentObserver;
import net.powermatcher.api.monitoring.ObservableAgent;
import net.powermatcher.core.BaseAgentEndpoint;
import net.powermatcher.core.BaseMatcherEndpoint;
import net.powermatcher.core.auctioneer.Auctioneer;
import net.powermatcher.core.bidcache.AggregatedBid;
import tcd.iainmeeke.core.predictioncache.AggregatedPrediction;

/**
 * <p>
 * This class represents a {@link Concentrator} component where several instances can be created.
 * </p>
 *
 * <p>
 * The {@link Concentrator} receives {@link Bid} from the agents and forwards this in an aggregate {@link Bid} up in the
 * hierarchy to a {@link Concentrator} or to the {@link Auctioneer}. It will receive price updates from the
 * {@link Auctioneer} and forward them to its connected agents.
 *
 * @author FAN
 * @version 2.1
 */
@Component(designateFactory = Concentrator.Config.class,
           immediate = true,
           provide = { AgentEndpoint.class, ObservableAgent.class, MatcherEndpoint.class })
public class Concentrator
    extends BaseAgentEndpoint
    implements MatcherEndpoint {

    private final BidHistoryStore sentBids = new BidHistoryStore();

    private final class MatcherPart
        extends BaseMatcherEndpoint {
        @Override
        public void init(String agentId) {
            super.init(agentId);
        }

        @Override
        protected void performUpdate(AggregatedBid aggregatedBid) {
            Bid bid = transformBid(aggregatedBid);
            synchronized (sentBids) {
                BidUpdate bidUpdate = publishBid(bid);
                if (bidUpdate != null) {
                    sentBids.saveBid(aggregatedBid, bidUpdate);
                }
            }
        }

        @Override
        protected void performUpdate(AggregatedPrediction aggregatedPrediction) {
            // Prediction prediction = transformPrediction(aggregatedPrediction);
            PredictionUpdate predictionUpdate = publishPrediction(aggregatedPrediction);
        }
    }

    @Meta.OCD
    public static interface Config {
        @Meta.AD(deflt = "concentrator")
        String agentId();

        @Meta.AD(deflt = "auctioneer")
        String desiredParentId();

        @Meta.AD(deflt = "1000",
                 description = "Mimimum time between two BidUpdates generated by the Concentratro in milliseconds")
        long minTimeBetweenBidUpdates();
    }

    private final MatcherPart matcherPart = new MatcherPart();

    protected Config config;

    /**
     * OSGi calls this method to activate a managed service.
     *
     * @param properties
     *            the configuration properties
     */
    @Activate
    public void activate(final Map<String, ?> properties) {
        activate(Configurable.createConfigurable(Config.class, properties));
    }

    /**
     * Convenient activate method that takes a {@link Config} object. This also makes subclassing easier.
     *
     * @param config
     *            The {@link Config} object that configures this concentrator
     */
    public void activate(Config config) {
        this.config = config;
        matcherPart.init(config.agentId());
        super.init(config.agentId(), config.desiredParentId());
        LOGGER.info("Concentrator [{}], activated", config.agentId());
    }

    @Override
    public void setContext(FlexiblePowerContext context) {
        super.setContext(context);
        matcherPart.setContext(context);
    }

    /**
     * OSGi calls this method to deactivate a managed service.
     */
    @Override
    @Deactivate
    public void deactivate() {
        AgentEndpoint.Status currentStatus = getStatus();

        if (currentStatus.isConnected()) {
            matcherEndpointDisconnected(currentStatus.getSession());
        }
        LOGGER.info("Concentrator [{}], deactivated", config.agentId());
    }

    @Override
    public void connectToMatcher(Session session) {
        super.connectToMatcher(session);
        matcherPart.configure(session.getMarketBasis(), session.getClusterId(), config.minTimeBetweenBidUpdates());
    }

    @Override
    public void matcherEndpointDisconnected(Session session) {
        synchronized (session) {
            matcherPart.unconfigure();
            super.matcherEndpointDisconnected(session);
        }
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void handlePriceUpdate(PriceUpdate priceUpdate) {
        super.handlePriceUpdate(priceUpdate);

        try {
            SentBidInformation info = sentBids.retrieveAggregatedBid(priceUpdate.getBidNumber());
            Price price = transformPrice(priceUpdate.getPrice(), info);
            matcherPart.publishPrice(price, info.getOriginalBid());
        } catch (IllegalArgumentException ex) {
            LOGGER.warn(ex.getMessage(), ex);
        }
    }

    @Override
    public void handleAllocationUpdate(AllocationUpdate allocationUpdate) {
        super.handleAllocationUpdate(allocationUpdate);
        matcherPart.publishAllocation(allocationUpdate.getAllocation());
    }

    /**
     * This method should be overridden when the bid that will be sent has to be changed.
     *
     * @param aggregatedBid
     *            The (input) aggregated bid as calculated normally (the sum of all the bids of the agents).
     * @return The bid that will be sent to the matcher that is connected to this {@link Concentrator}.
     */
    protected Bid transformBid(Bid aggregatedBid) {
        return aggregatedBid;
    }

    /**
     * This method should be overridden when the price that will be sent down has to be changed. This is called just
     * before the price will be sent down to the connected agents.
     *
     * @param price
     *            The input price update as received from the connected matcher.
     * @param info
     *            The information about the bid that has been send
     * @return The {@link Price} as it has to be sent to the connected agents.
     */
    protected Price transformPrice(Price price, SentBidInformation info) {
        return price;
    }

    /**
     * This method triggers a new {@link BidUpdate} from this concentrator, even when no child agent has updated its
     * {@link Bid}. This can be useful when the behavior of {@link #transformBid(Bid)} and/or
     * {@link #transformPrice(Price, SentBidInformation)} has changed. Note that when the resulting aggregated bid is
     * equal to the last aggregated bid, the {@link Concentrator} will not send a new {@link BidUpdate} (just like any
     * other PowerMatcher Agent).
     */
    protected void triggerBidUpdate() {
        matcherPart.performUpdate(matcherPart.aggregate());
    }

    // These method make sure that we implement the MatcherEndpoint
    // These just call the BaseMatcherEndpoint

    @Override
    public void agentEndpointDisconnected(Session session) {
        matcherPart.agentEndpointDisconnected(session);
    }

    @Override
    public void connectToAgent(Session session) {
        matcherPart.connectToAgent(session);
    }

    @Override
    public void handleBidUpdate(Session session, BidUpdate bidUpdate) {
        matcherPart.handleBidUpdate(session, bidUpdate);
    }

    @Override
    public void addObserver(AgentObserver observer) {
        super.addObserver(observer);
        matcherPart.addObserver(observer);
    }

    @Override
    public void removeObserver(AgentObserver observer) {
        super.removeObserver(observer);
        matcherPart.removeObserver(observer);
    }

    @Override
    public void handlePredictionUpdate(Session session, PredictionUpdate predictionUpdate) {
        matcherPart.handlePredictionUpdate(session, predictionUpdate);

    }
}
